# Terraform/OpenTofu Variables Configuration
# Copy this file to terraform.tfvars and fill in your actual values
# terraform.tfvars is git-ignored and contains sensitive data

# K3S Cluster Token
# Get from master node: sudo cat /var/lib/rancher/k3s/server/node-token
# Format: K10<random-hex>::server:<random-hex>
k3s_token = "K10YOUR_K3S_TOKEN_HERE::server:YOUR_SERVER_TOKEN_HERE"

# Network configuration
# DNS server IP address (optional, has default)
dns_server = "<dns-server-ip>"

# Gateway IP address (optional, has default)
gateway = "<gateway-ip>"

# NFS Storage configuration
# NFS server IP address or hostname (optional, has default)
nfs_server = "<nfs-server-ip>"

# NFS export path (optional, has default)
# Example: /mnt/pool/k3s-storage or /export/k3s-storage
nfs_export_path = "<nfs-export-path>"

# NFS mount options (optional, has default)
# Common options: rw (read-write), sync (synchronous writes), hard (hard mount), intr (interruptible)
nfs_mount_options = "rw,sync,hard,intr"

# Domain configuration
# Domain name for Ingress (e.g., example.com)
domain = "<your-domain>"

# Let's Encrypt configuration
# Email address for Let's Encrypt certificate registration
letsencrypt_email = "your-email@example.com"

# Cloudflare configuration
# API Token for Cloudflare DNS management (required for DNS-01 Challenge with Cloudflare)
# Create token at: https://dash.cloudflare.com/profile/api-tokens
# Required permissions: Zone:DNS:Edit for your domain
cloudflare_api_token = "<your-cloudflare-api-token>"

# Cloudflare account email (optional, defaults to letsencrypt_email if not set)
# Required for DNS-01 Challenge with Cloudflare. This is your Cloudflare account email.
# cloudflare_email = "your-email@example.com"

# DDNS bootstrap values (optional)
# These are initial placeholder IPs for DNS-only records; the DDNS updater will replace them automatically.
# ddns_bootstrap_ipv4 = "198.51.100.1"
# ddns_bootstrap_ipv6 = "2001:db8::1"
# ddns_enable_ipv6 = false

# Grafana configuration
# Admin password for Grafana
grafana_admin_password = "your-secure-password-here"

# Traefik Middlewares configuration
# Reusable middleware definitions for custom headers
# Define once and reference in multiple services to avoid duplication
traefik_middlewares = {
  # Standard headers for services behind reverse proxy
  # standard-headers = {
  #   headers = {
  #     frameDeny                = true
  #     sslRedirect              = true
  #     browserXssFilter         = true
  #     contentTypeNosniff       = true
  #     forceSTSHeader           = true
  #     stsIncludeSubdomains     = true
  #     stsPreload               = true
  #     stsSeconds               = 15552000
  #     customFrameOptionsValue  = "SAMEORIGIN"
  #     customRequestHeaders = {
  #       "X-Forwarded-Proto" = "https"
  #     }
  #   }
  # }
  
  # Headers for Proxmox VE
  # IMPORTANT: Proxmox makes its own redirects, so sslRedirect must be false to avoid redirect loops
  # proxmox-headers = {
  #   headers = {
  #     frameDeny                = true
  #     sslRedirect              = false  # IMPORTANT: false, since Proxmox makes its own redirects
  #     browserXssFilter         = true
  #     contentTypeNosniff       = true
  #     forceSTSHeader           = false  # Proxmox makes its own STS headers
  #     customRequestHeaders = {
  #       "X-Forwarded-Proto" = "https"
  #       "X-Forwarded-Host"  = "$host"  # IMPORTANT for Proxmox
  #     }
  #   }
  # }
  
  # Headers for Nextcloud
  # nextcloud-headers = {
  #   headers = {
  #     "X-Forwarded-Proto" = "https"
  #     "X-Forwarded-Host"  = "$host"
  #   }
  # }
}

# External services configuration
# Services running on other servers that should be accessible via Traefik
# Each service requires: domain, internal IP, port, optional path, optional custom headers (service-specific), optional middleware names (reusable), optional scheme (http/https), and optional insecure_skip_verify (for self-signed certificates)
external_services = {
  # Example: Service without headers or middlewares
  # myapp = {
  #   domain = "myapp.<your-domain>"
  #   ip     = "<external-server-ip>"
  #   port   = 8080
  #   path   = "/"
  # }
  
  # Example: Service using reusable middleware
  # nextcloud = {
  #   domain      = "nextcloud.<your-domain>"
  #   ip          = "<external-server-ip>"
  #   port        = 80
  #   path        = "/"
  #   middlewares = ["standard-headers", "nextcloud-headers"]
  # }
  
  # Example: Service with service-specific headers (not reusable)
  # api = {
  #   domain  = "api.<your-domain>"
  #   ip      = "<external-server-ip>"
  #   port    = 3000
  #   path    = "/api"
  #   headers = {
  #     "Authorization" = "Bearer token123"
  #   }
  # }
  
  # Example: Service using both reusable middleware and service-specific headers
  # webapp = {
  #   domain      = "webapp.<your-domain>"
  #   ip          = "<external-server-ip>"
  #   port        = 8080
  #   path        = "/"
  #   middlewares = ["standard-headers"]
  #   headers = {
  #     "X-Custom-Header" = "custom-value"
  #   }
  # }
  
  # Example: Service with self-signed certificate (e.g., Proxmox VE, TrueNAS)
  # IMPORTANT: Use proxmox-headers middleware, not standard-headers, to avoid redirect loops
  # proxmox = {
  #   domain             = "pve.<your-domain>"
  #   ip                 = "<external-server-ip>"
  #   port               = 8006
  #   path               = "/"
  #   scheme             = "https"
  #   insecure_skip_verify = true
  #   middlewares        = ["proxmox-headers"]
  # }
  
  # Example: Service with HTTPS backend (e.g., Bitwarden)
  # bitwarden = {
  #   domain             = "bitwarden.<your-domain>"
  #   ip                 = "<external-server-ip>"
  #   port               = 9890
  #   path               = "/"
  #   scheme             = "https"
  #   insecure_skip_verify = true
  #   middlewares        = ["standard-headers"]
  # }
}

# User configuration
# Password hash for the kairos user
# Generate with: openssl passwd -6 -salt $(openssl rand -base64 6)
# Or use existing hash from Kairos installation
password_hash = "$6$YOUR_SALT_HERE$YOUR_PASSWORD_HASH_HERE"

# SSH public key for the kairos user
# Usually from: cat ~/.ssh/id_rsa.pub
# Format: ssh-rsa <key-data> <comment>
ssh_public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQ... your-email@example.com"

# Cluster nodes configuration
# Define all nodes in your cluster
# Key: unique identifier (used for hostname generation)
# host: IP address of the node
# role: "master" or "worker"
nodes = {
  # Master node (required - exactly one)
  master = {
    host = "<master-node-ip>"
    role = "master"
  }
  # Worker nodes 
  worker1 = {
    host = "<worker-node-1-ip>"
    role = "worker"
  }
  worker2 = {
    host = "<worker-node-2-ip>"
    role = "worker"
  }
  worker3 = {
    host = "<worker-node-3-ip>"
    role = "worker"
  }
}

# Notes:
# - Hostnames are automatically generated:
#   - Master: k3s-master
#   - Workers: k3s-worker-1, k3s-worker-3, etc.
# - All nodes must be reachable via SSH with the configured key
# - The kairos user must exist on all nodes with sudo privileges

