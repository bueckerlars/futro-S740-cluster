# Terraform/OpenTofu Variables Configuration
# Copy this file to terraform.tfvars and fill in your actual values
# terraform.tfvars is git-ignored and contains sensitive data

# K3S Cluster Token
# Get from master node: sudo cat /var/lib/rancher/k3s/server/node-token
# Format: K10<random-hex>::server:<random-hex>
k3s_token = "K10YOUR_K3S_TOKEN_HERE::server:YOUR_SERVER_TOKEN_HERE"

# Network configuration
# DNS server IP address (optional, has default)
dns_server = "192.168.1.11"

# Gateway IP address (optional, has default)
gateway = "192.168.1.1"

# NFS Storage configuration
# NFS server IP address or hostname (optional, has default)
nfs_server = "192.168.1.10"

# NFS export path (optional, has default)
# TrueNAS Scale 2025 path format
nfs_export_path = "/mnt/SSD-Pool/k3s-storage"

# NFS mount options (optional, has default)
# Common options: rw (read-write), sync (synchronous writes), hard (hard mount), intr (interruptible)
nfs_mount_options = "rw,sync,hard,intr"

# Domain configuration
# Domain name for Ingress
domain = "<your-domain>"

# Let's Encrypt configuration
# Email address for Let's Encrypt certificate registration
letsencrypt_email = "your-email@example.com"

# Grafana configuration
# Admin password for Grafana
grafana_admin_password = "your-secure-password-here"

# Traefik Middlewares configuration
# Reusable middleware definitions for custom headers
# Define once and reference in multiple services to avoid duplication
traefik_middlewares = {
  # Standard headers for services behind reverse proxy
  # standard-headers = {
  #   headers = {
  #     frameDeny                = true
  #     sslRedirect              = true
  #     browserXssFilter         = true
  #     contentTypeNosniff       = true
  #     forceSTSHeader           = true
  #     stsIncludeSubdomains     = true
  #     stsPreload               = true
  #     stsSeconds               = 15552000
  #     customFrameOptionsValue  = "SAMEORIGIN"
  #     customRequestHeaders = {
  #       "X-Forwarded-Proto" = "https"
  #     }
  #   }
  # }
  
  # Headers for Proxmox VE
  # IMPORTANT: Proxmox makes its own redirects, so sslRedirect must be false to avoid redirect loops
  # proxmox-headers = {
  #   headers = {
  #     frameDeny                = true
  #     sslRedirect              = false  # IMPORTANT: false, since Proxmox makes its own redirects
  #     browserXssFilter         = true
  #     contentTypeNosniff       = true
  #     forceSTSHeader           = false  # Proxmox makes its own STS headers
  #     customRequestHeaders = {
  #       "X-Forwarded-Proto" = "https"
  #       "X-Forwarded-Host"  = "$host"  # IMPORTANT for Proxmox
  #     }
  #   }
  # }
  
  # Headers for Nextcloud
  # nextcloud-headers = {
  #   headers = {
  #     "X-Forwarded-Proto" = "https"
  #     "X-Forwarded-Host"  = "$host"
  #   }
  # }
}

# External services configuration
# Services running on other servers that should be accessible via Traefik
# Each service requires: domain, internal IP, port, optional path, optional custom headers (service-specific), optional middleware names (reusable), optional scheme (http/https), and optional insecure_skip_verify (for self-signed certificates)
external_services = {
  # Example: Service without headers or middlewares
  # myapp = {
  #   domain = "myapp.<your-domain>"
  #   ip     = "192.168.1.20"
  #   port   = 8080
  #   path   = "/"
  # }
  
  # Example: Service using reusable middleware
  # nextcloud = {
  #   domain      = "nextcloud.<your-domain>"
  #   ip          = "192.168.1.25"
  #   port        = 80
  #   path        = "/"
  #   middlewares = ["standard-headers", "nextcloud-headers"]
  # }
  
  # Example: Service with service-specific headers (not reusable)
  # api = {
  #   domain  = "api.<your-domain>"
  #   ip      = "192.168.1.30"
  #   port    = 3000
  #   path    = "/api"
  #   headers = {
  #     "Authorization" = "Bearer token123"
  #   }
  # }
  
  # Example: Service using both reusable middleware and service-specific headers
  # webapp = {
  #   domain      = "webapp.<your-domain>"
  #   ip          = "192.168.1.35"
  #   port        = 8080
  #   path        = "/"
  #   middlewares = ["standard-headers"]
  #   headers = {
  #     "X-Custom-Header" = "custom-value"
  #   }
  # }
  
  # Example: Service with self-signed certificate (e.g., Proxmox VE, TrueNAS)
  # IMPORTANT: Use proxmox-headers middleware, not standard-headers, to avoid redirect loops
  # proxmox = {
  #   domain             = "pve.<your-domain>"
  #   ip                 = "192.168.1.3"
  #   port               = 8006
  #   path               = "/"
  #   scheme             = "https"
  #   insecure_skip_verify = true
  #   middlewares        = ["proxmox-headers"]
  # }
  
  # Example: Service with HTTPS backend (e.g., Bitwarden)
  # bitwarden = {
  #   domain             = "bitwarden.<your-domain>"
  #   ip                 = "192.168.1.4"
  #   port               = 9890
  #   path               = "/"
  #   scheme             = "https"
  #   insecure_skip_verify = true
  #   middlewares        = ["standard-headers"]
  # }
}

# User configuration
# Password hash for the kairos user
# Generate with: openssl passwd -6 -salt $(openssl rand -base64 6)
# Or use existing hash from Kairos installation
password_hash = "$6$YOUR_SALT_HERE$YOUR_PASSWORD_HASH_HERE"

# SSH public key for the kairos user
# Usually from: cat ~/.ssh/id_rsa.pub
# Format: ssh-rsa <key-data> <comment>
ssh_public_key = "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQ... your-email@example.com"

# Cluster nodes configuration
# Define all nodes in your cluster
# Key: unique identifier (used for hostname generation)
# host: IP address of the node
# role: "master" or "worker"
nodes = {
  # Master node (required - exactly one)
  master = {
    host = "192.168.1.15"
    role = "master"
  }
  # Worker nodes 
  worker1 = {
    host = "192.168.1.16"
    role = "worker"
  }
  worker2 = {
    host = "192.168.1.17"
    role = "worker"
  }
  worker3 = {
    host = "192.168.1.18"
    role = "worker"
  }
}

# Notes:
# - Hostnames are automatically generated:
#   - Master: k3s-master
#   - Workers: k3s-worker-1, k3s-worker-3, etc.
# - All nodes must be reachable via SSH with the configured key
# - The kairos user must exist on all nodes with sudo privileges

